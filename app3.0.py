# -*- coding: utf-8 -*-
"""
AI 趨勢分析 Streamlit 應用程式
專家增強最終版實作

本應用程式根據一份詳細的金融分析工具設定文件進行開發，
旨在提供一個整合性的股票、ETF、指數及加密貨幣的 AI 趨勢分析平台。

核心功能：
- 多元化資產選擇介面
- 統一技術指標計算引擎
- 雙軌制基本面評分系統
- AI 融合信號生成模型
- 多策略共識風險管理 (止盈/止損)
- 標準化策略回測引擎
- 線性化報告與綜合圖表展示

開發者：程式碼專家 (Generated by Gemini)
版本：1.4.0 (Feature update: Added Entry Price & News Links)
"""

# 載入核心套件
import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import pandas_ta as ta
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# --- 1. 應用程式全域設定與靜態資料 ---

# 設置頁面配置 (寬版)
st.set_page_config(
    page_title="🚀 AI 趨勢分析專家系統",
    page_icon="📈",
    layout="wide"
)

# 資產庫 (FULL_SYMBOLS_MAP) - 根據文件建立的精簡版資產池
# 每個資產包含: 代碼 (Symbol), 名稱 (Name), 關鍵字 (Keywords)
FULL_SYMBOLS_MAP = {
    '美股': {
        'AAPL': {'name': '蘋果', 'keywords': ['Apple', 'iPhone']},
        'GOOGL': {'name': 'Alphabet (Google)', 'keywords': ['google', 'android']},
        'MSFT': {'name': '微軟', 'keywords': ['Microsoft', 'windows']},
        'NVDA': {'name': '輝達', 'keywords': ['Nvidia', 'AI', 'GPU']},
        'TSLA': {'name': '特斯拉', 'keywords': ['Tesla', 'EV']},
        'SPY': {'name': 'S&P 500 ETF', 'keywords': ['sp500', 'index']},
        '^GSPC': {'name': 'S&P 500 指數', 'keywords': ['spx']}
    },
    '台股': {
        '2330.TW': {'name': '台積電', 'keywords': ['TSMC']},
        '2317.TW': {'name': '鴻海', 'keywords': ['foxconn']},
        '2454.TW': {'name': '聯發科', 'keywords': ['mediatek']},
        '0050.TW': {'name': '元大台灣50', 'keywords': ['etf']},
        '^TWII': {'name': '台灣加權指數', 'keywords': ['taiex']}
    },
    '加密貨幣': {
        'BTC-USD': {'name': '比特幣', 'keywords': ['Bitcoin']},
        'ETH-USD': {'name': '以太幣', 'keywords': ['Ethereum']},
        'SOL-USD': {'name': 'Solana', 'keywords': ['sol']},
    }
}

# 分析週期 (PERIOD_MAP) - UI 選項與 yfinance API 參數的映射
PERIOD_MAP = {
    '30 分': {'period': '60d', 'interval': '30m'},
    '4 小時': {'period': '1y', 'interval': '60m'},
    '1 日': {'period': '5y', 'interval': '1d'},
    '1 週': {'period': 'max', 'interval': '1wk'}
}

# --- 2. 核心功能函式 (後端邏輯) ---

@st.cache_data(ttl=600) # 快取數據 10 分鐘
def get_data(symbol, period, interval):
    """
    使用 yfinance 獲取指定資產的歷史市場數據。
    Args:
        symbol (str): 資產代碼
        period (str): 歷史數據期間 (e.g., '5y')
        interval (str): 數據時間間隔 (e.g., '1d')
    Returns:
        pd.DataFrame: 包含 OHLCV 數據的 DataFrame，若失敗則返回 None。
    """
    try:
        ticker = yf.Ticker(symbol)
        df = ticker.history(period=period, interval=interval)
        if df.empty:
            st.error(f"錯誤：無法獲取 '{symbol}' 的數據。請檢查代碼或更換分析週期。")
            return None
        df.index = pd.to_datetime(df.index)
        # 對於加密貨幣，yfinance 的 index 可能是 UTC，需要轉換
        if 'USD' in symbol:
             df.index = df.index.tz_convert(None)
        else:
             df.index = df.index.tz_localize(None)
        return df
    except Exception as e:
        st.error(f"數據獲取時發生錯誤：{e}")
        return None

@st.cache_data
def calculate_indicators(df):
    """
    統一計算所有必要的技術指標。
    使用 pandas-ta 套件簡化計算過程。
    Args:
        df (pd.DataFrame): 包含 OHLCV 數據的 DataFrame。
    Returns:
        pd.DataFrame: 附加了技術指標欄位的 DataFrame。
    """
    # 趨勢指標
    df.ta.ema(length=10, append=True)
    df.ta.ema(length=50, append=True)
    df.ta.ema(length=200, append=True)
    df.ta.macd(fast=12, slow=26, signal=9, append=True) # AI信號生成用
    df.ta.adx(length=14, append=True)

    # 動能指標
    df.ta.rsi(length=9, append=True)
    df.ta.rsi(length=14, append=True)

    # 波動率指標
    df.ta.bbands(length=20, std=2, append=True)
    df.ta.atr(length=14, append=True)

    # 量能指標
    df.ta.obv(append=True)
    df.ta.cmf(length=20, append=True)

    df.dropna(inplace=True)
    return df

@st.cache_data(ttl=3600)
def get_fundamental_data(symbol):
    """
    獲取基本面數據與新聞。
    注意：yfinance 的基本面數據可能不完整或延遲。
    Args:
        symbol (str): 資產代碼。
    Returns:
        dict: 包含基本面數據和新聞的字典。
    """
    try:
        if any(keyword in symbol for keyword in ['-USD', '^']):
             return {'info': {}, 'news': [{'title': '指數或加密貨幣無基本面/新聞數據'}]}

        ticker = yf.Ticker(symbol)
        info = ticker.info
        news = ticker.news
        return {'info': info, 'news': news[:5]} # 只取最新的5條新聞
    except Exception:
        return {'info': {}, 'news': [{'title': '無法獲取此資產的基本面/新聞數據'}]}

def calculate_fundamental_scores(info):
    """
    雙軌制基本面評分。
    Args:
        info (dict): 來自 yfinance 的 Ticker.info 字典。
    Returns:
        dict: 包含 AI_SCORE 和 DISPLAY_SCORE 的字典。
    """
    # 初始化分數
    ai_score = 0
    display_score = 0
    
    # 評分標準
    roe = info.get('returnOnEquity', 0)
    debt_to_equity = info.get('debtToEquity')
    revenue_growth = info.get('revenueGrowth', 0)
    pe_ratio = info.get('trailingPE')
    peg_ratio = info.get('pegRatio')
    free_cash_flow = info.get('freeCashflow', 0)
    total_cash = info.get('totalCash', 0)
    total_debt = info.get('totalDebt', 1) # 避免除以零

    # --- AI融合分數 (AI_SCORE) - 總分7分 ---
    if roe is not None and roe > 0.15: ai_score += 2
    if debt_to_equity is not None and debt_to_equity < 50: ai_score += 2
    if revenue_growth is not None and revenue_growth > 0.10: ai_score += 1
    if pe_ratio is not None and pe_ratio < 15: ai_score += 1
    if peg_ratio is not None and peg_ratio < 1: ai_score += 1
    
    # --- 介面顯示分數 (DISPLAY_SCORE) - 總分9分 ---
    # ROE 評分 (3分)
    if roe is not None:
        if roe > 0.15: display_score += 3
        elif roe > 0.10: display_score += 2
        elif roe > 0: display_score += 1
    
    # P/E 評分 (3分)
    if pe_ratio is not None:
        if pe_ratio < 15: display_score += 3
        elif pe_ratio < 25: display_score += 2
        elif pe_ratio < 35: display_score += 1
        
    # 現金流/債務評分 (3分)
    if free_cash_flow > 0 and total_cash > total_debt:
        display_score += 3
    elif free_cash_flow > 0 or total_cash > total_debt:
        display_score += 2
    elif total_cash > total_debt * 0.5:
        display_score += 1
        
    return {'ai_score': ai_score, 'display_score': display_score}

def generate_ai_fusion_signal(df, fa_score):
    """
    AI 融合信號生成模型。
    根據技術面、基本面數據加權融合，產生最終行動建議。
    Args:
        df (pd.DataFrame): 包含技術指標的 DataFrame。
        fa_score (int): 基本面 AI_SCORE。
    Returns:
        dict: 包含總分、行動建議和信心指數的字典。
    """
    latest = df.iloc[-1]
    prev = df.iloc[-2]
    total_score = 0

    # 1. 趨勢分數 (MA Score)
    ma_score = 0
    if latest['EMA_10'] > latest['EMA_50'] and prev['EMA_10'] <= prev['EMA_50']:
        ma_score = 3.5  # 黃金交叉
    elif latest['EMA_10'] < latest['EMA_50'] and prev['EMA_10'] >= prev['EMA_50']:
        ma_score = -3.5 # 死亡交叉
    elif latest['EMA_10'] > latest['EMA_50'] and latest['EMA_50'] > latest['EMA_200']:
        ma_score = 2.0   # 強多頭排列
    elif latest['EMA_10'] < latest['EMA_50'] and latest['EMA_50'] < latest['EMA_200']:
        ma_score = -2.0  # 強空頭排列
    total_score += ma_score

    # 2. 動能分數 (Momentum Score)
    momentum_score = 0
    if latest['RSI_14'] < 40:
        momentum_score = 2.0 # 超賣區間，潛在買入
    elif latest['RSI_14'] > 60:
        momentum_score = -2.0 # 超買區間，潛在賣出
    total_score += momentum_score
        
    # 3. 強度分數 (Strength Score)
    strength_score = 0
    if latest['MACDh_12_26_9'] > 0 and latest['MACDh_12_26_9'] > prev['MACDh_12_26_9']:
        strength_score = 1.5 # MACD 柱狀圖放大
    elif latest['MACDh_12_26_9'] < 0 and latest['MACDh_12_26_9'] < prev['MACDh_12_26_9']:
        strength_score = -1.5 # MACD 柱狀圖縮小
    
    # ADX 加權
    if latest['ADX_14'] > 25:
        strength_score *= 1.5
    total_score += strength_score

    # 4. K線分數 (Kline Score)
    kline_score = 0
    body_size = abs(latest['Close'] - latest['Open'])
    if 'ATRr_14' in latest.index and body_size > 0.7 * latest['ATRr_14']:
        if latest['Close'] > latest['Open']:
            kline_score = 1.0 # 大陽線
        else:
            kline_score = -1.0 # 大陰線
    total_score += kline_score
    
    # 5. 基本面正規化分數 (FA Normalized Score)
    # 將7分制的基本面分數轉換為 -3 至 +3 的區間
    if fa_score > 0:
      fa_normalized_score = (fa_score / 7) * 3 
      total_score += fa_normalized_score

    # 產生最終行動建議
    if total_score >= 4.0:
        action = "買進 (Buy)"
    elif 1.0 <= total_score < 4.0:
        action = "中性偏買 (Hold/Buy)"
    elif -1.0 < total_score < 1.0:
        action = "觀望 (Neutral)"
    elif -4.0 < total_score <= -1.0:
        action = "中性偏賣 (Hold/Sell)"
    else:
        action = "賣出 (Sell/Short)"

    # 計算信心指數 (0-100)
    confidence = min(int(abs(total_score) / 8.0 * 100), 100)
        
    return {'total_score': round(total_score, 2), 'action': action, 'confidence': confidence}

def calculate_entry_price(action, latest):
    """
    (NEW v1.4.0) 根據 AI 行動建議計算建議的入場價位。
    Args:
        action (str): AI 的行動建議 (e.g., "買進 (Buy)")
        latest (pd.Series): 最新一筆包含指標的數據
    Returns:
        float or str: 計算出的入場價或 "N/A"
    """
    entry_price = "N/A"
    # 多頭訊號：建議在小幅回調時買入 (參考 EMA_10 或 ATR)
    if 'Buy' in action:
        if 'EMA_10' in latest.index and pd.notna(latest['EMA_10']):
            entry_price = latest['EMA_10']
        elif 'ATRr_14' in latest.index and pd.notna(latest['ATRr_14']):
            entry_price = latest['Close'] - 0.25 * latest['ATRr_14']
        else: # 備用方案
            entry_price = latest['Close'] * 0.995
    # 空頭訊號：建議在小幅反彈時賣出 (參考 EMA_10 或 ATR)
    elif 'Sell' in action:
        if 'EMA_10' in latest.index and pd.notna(latest['EMA_10']):
            entry_price = latest['EMA_10']
        elif 'ATRr_14' in latest.index and pd.notna(latest['ATRr_14']):
            entry_price = latest['Close'] + 0.25 * latest['ATRr_14']
        else: # 備用方案
            entry_price = latest['Close'] * 1.005
    
    if isinstance(entry_price, (int, float)):
        return round(entry_price, 2)
    return entry_price

def calculate_risk_management(df):
    """
    多策略共識止盈止損計算。
    Args:
        df (pd.DataFrame): 包含指標的 DataFrame。
    Returns:
        dict: 包含共識止盈 (TP) 和止損 (SL) 價位的字典。
    """
    latest = df.iloc[-1]
    sl_prices, tp_prices = [], []

    # 策略1: ATR 停損
    if 'ATRr_14' in latest.index and pd.notna(latest['ATRr_14']):
        sl_prices.append(latest['Close'] - 2 * latest['ATRr_14'])
        tp_prices.append(latest['Close'] + 2 * latest['ATRr_14'])

    # 策略2: 布林通道
    if 'BBL_20_2.0' in latest.index and 'BBU_20_2.0' in latest.index:
        sl_prices.append(latest['BBL_20_2.0'])
        tp_prices.append(latest['BBU_20_2.0'])
    
    # 策略3: 前期高低點 (近30根K棒)
    if len(df) >= 30:
        recent_df = df.iloc[-30:]
        sl_prices.append(recent_df['Low'].min())
        tp_prices.append(recent_df['High'].max())
    elif not df.empty:
        sl_prices.append(df['Low'].min())
        tp_prices.append(df['High'].max())

    # 如果沒有任何策略成功計算，則提供一個基於當前價格的備用方案
    if not sl_prices or not tp_prices:
        fallback_atr = latest.get('ATRr_14', latest['Close'] * 0.05)
        if pd.isna(fallback_atr): fallback_atr = latest['Close'] * 0.05
        
        sl = latest['Close'] - 2 * fallback_atr
        tp = latest['Close'] + 2 * fallback_atr
        return {'sl': round(sl, 2), 'tp': round(tp, 2)}

    # 共識價計算演算法
    consensus_sl = np.mean(sorted(sl_prices, reverse=True)[:2])
    consensus_tp = np.mean(sorted(tp_prices)[:2])

    return {'sl': round(consensus_sl, 2), 'tp': round(consensus_tp, 2)}

def run_backtest(df):
    """
    策略回測引擎: SMA 20 / EMA 50 均線交叉策略。
    Args:
        df (pd.DataFrame): 包含指標的 DataFrame。
    Returns:
        dict: 包含回測結果指標與資金曲線的字典。
    """
    # 確保指標存在
    if 'EMA_50' not in df.columns:
        df.ta.ema(length=50, append=True)
    
    # 為了回測，我們需要一個短期的SMA
    df['SMA_20'] = ta.sma(df['Close'], length=20)
    df.dropna(inplace=True)
    
    if df.empty:
        return {'total_return': 0, 'win_rate': 0, 'max_drawdown': 0, 'trades_count': 0, 'equity_curve': pd.Series([1.0])}

    # 產生交易信號
    df['signal'] = 0
    df.loc[(df['SMA_20'] > df['EMA_50']) & (df['SMA_20'].shift(1) <= df['EMA_50'].shift(1)), 'signal'] = 1  # 買進
    df.loc[(df['SMA_20'] < df['EMA_50']) & (df['SMA_20'].shift(1) >= df['EMA_50'].shift(1)), 'signal'] = -1 # 賣出

    # 執行回測
    position = 0
    trades = []
    entry_price = 0
    for i, row in df.iterrows():
        if position == 0 and row['signal'] == 1:
            position = 1
            entry_price = row['Close']
        elif position == 1 and row['signal'] == -1:
            position = 0
            exit_price = row['Close']
            trades.append((exit_price / entry_price) - 1)

    if not trades:
        return {'total_return': 0, 'win_rate': 0, 'max_drawdown': 0, 'trades_count': 0, 'equity_curve': pd.Series([1.0])}
        
    # 計算回測指標
    trades_count = len(trades)
    wins = [t for t in trades if t > 0]
    win_rate = len(wins) / trades_count * 100 if trades_count > 0 else 0
    
    # 計算資金曲線和總回報
    equity = (pd.Series(trades) + 1).cumprod()
    total_return = (equity.iloc[-1] - 1) * 100 if not equity.empty else 0

    # 計算最大回撤
    peak = equity.cummax()
    drawdown = (equity - peak) / peak
    max_drawdown = abs(drawdown.min()) * 100

    return {
        'total_return': round(total_return, 2),
        'win_rate': round(win_rate, 2),
        'max_drawdown': round(max_drawdown, 2),
        'trades_count': trades_count,
        'equity_curve': equity
    }

# --- 3. Streamlit 使用者介面 (UI) ---

# --- 側邊欄控制項 ---
with st.sidebar:
    st.image("https://storage.googleapis.com/gemini-prod/images/workspace_icon_for_light_background.png", width=80)
    st.header("⚙️ 分析設定")
    
    # 1. 資產選擇
    st.subheader("1. 選擇分析資產")
    asset_category = st.selectbox("資產類別", list(FULL_SYMBOLS_MAP.keys()))
    
    popular_assets = {f"{symbol} ({details['name']})": symbol for symbol, details in FULL_SYMBOLS_MAP[asset_category].items()}
    selected_popular = st.selectbox("熱門標的", list(popular_assets.keys()))
    
    manual_input = st.text_input("或手動輸入代碼 (優先使用)", placeholder="例如: 2330.TW, TSLA")

    # (FIXED v1.2.0) 決定最終分析的 symbol, 修正UI邏輯
    # 只有當 manual_input 非空時才優先使用
    if manual_input.strip():
        final_symbol = manual_input.strip().upper()
        # 嘗試從 map 中找到名稱
        try:
           # 搜尋所有類別以找到匹配的代碼
           all_symbols = {s: d['name'] for cat in FULL_SYMBOLS_MAP.values() for s, d in cat.items()}
           final_symbol_name = all_symbols.get(final_symbol, "")
        except Exception:
           final_symbol_name = ""
    else:
        final_symbol = popular_assets[selected_popular]
        final_symbol_name = FULL_SYMBOLS_MAP[asset_category][final_symbol]['name']
        
    st.info(f"當前目標: **{final_symbol} ({final_symbol_name})**")

    # 2. 週期設定
    st.subheader("2. 選擇分析週期")
    selected_period_label = st.selectbox("時間週期", list(PERIOD_MAP.keys()))
    period_params = PERIOD_MAP[selected_period_label]

    # 3. 執行分析
    st.subheader("3. 執行分析")
    start_analysis = st.button("📊 執行 AI 分析", use_container_width=True, type="primary")

# --- 主畫面顯示區 ---
st.title("🚀 AI 趨勢分析專家系統")
st.caption(f"數據更新時間: {pd.Timestamp.now('Asia/Taipei').strftime('%Y-%m-%d %H:%M:%S CST')}")

if start_analysis:
    with st.spinner('AI 分析引擎啟動中，請稍候...'):
        # 步驟 1: 獲取數據
        data = get_data(final_symbol, period_params['period'], period_params['interval'])

        if data is not None and not data.empty:
            # 步驟 2: 計算技術指標
            data_with_indicators = calculate_indicators(data.copy())
            
            if data_with_indicators.empty or len(data_with_indicators) < 2:
                st.error("錯誤：計算技術指標後無有效數據，可能是歷史數據過短。請嘗試更長的分析週期。")
            else:
                # 步驟 3: 獲取基本面數據與評分
                funda_data = get_fundamental_data(final_symbol)
                funda_scores = calculate_fundamental_scores(funda_data['info'])
                
                # 步驟 4: 生成 AI 融合信號
                ai_signal = generate_ai_fusion_signal(data_with_indicators, funda_scores['ai_score'])
                
                # 步驟 5: 計算風險管理與入場價位
                risk_levels = calculate_risk_management(data_with_indicators)
                entry_price = calculate_entry_price(ai_signal['action'], data_with_indicators.iloc[-1])
                
                # 步驟 6: 執行策略回測
                backtest_results = run_backtest(data_with_indicators.copy())

                # ----------------------------------------
                # --- 分析結果頁面佈局 (線性報告格式) ---
                # ----------------------------------------
                
                st.markdown("---")
                
                # 1. 主標題
                funda_rating = f"基本面評級: {funda_scores['display_score']}/9" if funda_scores['display_score'] > 0 else "基本面評級: N/A"
                st.header(f"📈 {final_symbol_name} ({final_symbol}) - {selected_period_label} 分析報告")
                st.subheader(funda_rating)
                
                st.markdown("---")

                # 2. 核心行動與量化評分
                st.subheader("🎯 核心行動與量化評分")
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("當前價格", f"{data_with_indicators['Close'].iloc[-1]:,.2f}")
                col2.metric("最終行動建議", ai_signal['action'])
                col3.metric("總量化評分", f"{ai_signal['total_score']:.2f}")
                col4.metric("信心指數", f"{ai_signal['confidence']}%")
                
                # 3. 精確交易策略與風險控制
                st.subheader("🛡️ 精確交易策略與風險控制")
                # (UPDATED v1.4.0) 新增第四欄顯示建議入場價
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("建議操作", ai_signal['action'].split(" ")[0])
                col2.metric("建議入場價", f"{entry_price:,.2f}" if isinstance(entry_price, (int, float)) else "N/A")
                col3.metric("共識止盈價 (TP)", f"{risk_levels['tp']:,.2f}", delta=f"{((risk_levels['tp']/data_with_indicators['Close'].iloc[-1])-1)*100:.2f}%")
                col4.metric("共識止損價 (SL)", f"{risk_levels['sl']:,.2f}", delta=f"{((risk_levels['sl']/data_with_indicators['Close'].iloc[-1])-1)*100:.2f}%", delta_color="inverse")
                
                st.markdown("---")
                
                col_main, col_side = st.columns([2,1])
                
                with col_main:
                    # 4. 關鍵技術指標數據與AI判讀
                    st.subheader("🔬 關鍵技術指標數據")
                    latest_indicators = data_with_indicators.iloc[-1]
                    
                    bbl_val = latest_indicators.get('BBL_20_2.0')
                    bbu_val = latest_indicators.get('BBU_20_2.0')
                    
                    bbl_str = f"{bbl_val:.1f}" if isinstance(bbl_val, (int, float)) else "N/A"
                    bbu_str = f"{bbu_val:.1f}" if isinstance(bbu_val, (int, float)) else "N/A"
                    bollinger_str = f"{bbl_str} - {bbu_str}"

                    if isinstance(bbl_val, (int, float)) and isinstance(bbu_val, (int, float)) and latest_indicators.get('Close', 1) > 0:
                        band_width = (bbu_val - bbl_val) / latest_indicators.get('Close', 1)
                        volatility_judgement = "波動放大" if band_width > 0.05 else "波動收斂"
                    else:
                        volatility_judgement = "N/A"

                    indicators_df = pd.DataFrame({
                        '指標': ['RSI (14)', 'MACD (12,26,9)', 'ADX (14)', 'CMF (20)', '布林通道'],
                        '數值': [
                            f"{latest_indicators.get('RSI_14', 'N/A'):.2f}",
                            f"{latest_indicators.get('MACD_12_26_9', 'N/A'):.2f}",
                            f"{latest_indicators.get('ADX_14', 'N/A'):.2f}",
                            f"{latest_indicators.get('CMF_20', 'N/A'):.2f}",
                            bollinger_str
                        ],
                        'AI 判讀': [
                            "趨於超買" if latest_indicators.get('RSI_14', 50) > 65 else ("趨於超賣" if latest_indicators.get('RSI_14', 50) < 35 else "中性"),
                            "多頭" if latest_indicators.get('MACDh_12_26_9', 0) > 0 else "空頭",
                            "強趨勢" if latest_indicators.get('ADX_14', 0) > 25 else "盤整",
                            "資金流入" if latest_indicators.get('CMF_20', 0) > 0 else "資金流出",
                            volatility_judgement
                        ]
                    })
                    st.table(indicators_df)

                with col_side:
                    # 最新相關新聞
                    st.subheader("📰 最新相關新聞")
                    # (UPDATED v1.4.0) 新聞標題改為可點擊的超連結
                    for news_item in funda_data['news']:
                        title = news_item.get('title', '新聞標題不可用')
                        link = news_item.get('link')
                        if link:
                            st.markdown(f"- [{title}]({link})")
                        else:
                            st.markdown(f"- {title}")
                
                st.markdown("---")

                # 5. 策略回測報告
                st.subheader(f"🔙 策略回測報告 (SMA 20 / EMA 50 交叉)")
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("總回報率", f"{backtest_results['total_return']:.2f}%")
                col2.metric("勝率", f"{backtest_results['win_rate']:.2f}%")
                col3.metric("最大回撤", f"{backtest_results['max_drawdown']:.2f}%")
                col4.metric("總交易次數", backtest_results['trades_count'])
                
                # 資金曲線圖
                if backtest_results['trades_count'] > 0:
                    equity_curve = (backtest_results['equity_curve'] + 1)
                    equity_fig = go.Figure()
                    equity_fig.add_trace(go.Scatter(x=equity_curve.index, y=equity_curve.values, mode='lines', name='Equity'))
                    equity_fig.update_layout(title='資金曲線圖', xaxis_title='交易次數', yaxis_title='累計回報')
                    st.plotly_chart(equity_fig, use_container_width=True)
                
                st.markdown("---")

                # 6. 完整技術分析圖表
                st.subheader("📊 完整技術分析圖表")
                
                # 建立包含4個子圖的圖表
                fig = make_subplots(rows=4, cols=1, shared_xaxes=True, 
                                    vertical_spacing=0.03, row_heights=[0.5, 0.15, 0.15, 0.2])

                # 圖 1: K線與移動平均線
                fig.add_trace(go.Candlestick(x=data_with_indicators.index,
                                             open=data_with_indicators['Open'],
                                             high=data_with_indicators['High'],
                                             low=data_with_indicators['Low'],
                                             close=data_with_indicators['Close'], name='K線'), row=1, col=1)
                fig.add_trace(go.Scatter(x=data_with_indicators.index, y=data_with_indicators['EMA_10'], mode='lines', name='EMA 10', line=dict(color='orange', width=1)), row=1, col=1)
                fig.add_trace(go.Scatter(x=data_with_indicators.index, y=data_with_indicators['EMA_50'], mode='lines', name='EMA 50', line=dict(color='blue', width=1)), row=1, col=1)
                fig.add_trace(go.Scatter(x=data_with_indicators.index, y=data_with_indicators['EMA_200'], mode='lines', name='EMA 200', line=dict(color='purple', width=2, dash='dash')), row=1, col=1)
                
                # 圖 2: 成交量
                fig.add_trace(go.Bar(x=data_with_indicators.index, y=data_with_indicators['Volume'], name='成交量'), row=2, col=1)

                # 圖 3: MACD
                fig.add_trace(go.Bar(x=data_with_indicators.index, y=data_with_indicators['MACDh_12_26_9'], name='MACD Histogram'), row=3, col=1)
                fig.add_trace(go.Scatter(x=data_with_indicators.index, y=data_with_indicators['MACD_12_26_9'], mode='lines', name='MACD', line=dict(color='blue', width=1)), row=3, col=1)
                fig.add_trace(go.Scatter(x=data_with_indicators.index, y=data_with_indicators['MACDs_12_26_9'], mode='lines', name='Signal', line=dict(color='orange', width=1)), row=3, col=1)

                # 圖 4: RSI
                fig.add_trace(go.Scatter(x=data_with_indicators.index, y=data_with_indicators['RSI_14'], mode='lines', name='RSI 14'), row=4, col=1)
                fig.add_hline(y=70, line_dash="dash", row=4, col=1, line_color="red")
                fig.add_hline(y=30, line_dash="dash", row=4, col=1, line_color="green")
                
                # 更新圖表佈局
                fig.update_layout(
                    height=800,
                    xaxis_rangeslider_visible=False,
                    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
                )
                fig.update_yaxes(title_text="價格", row=1, col=1)
                fig.update_yaxes(title_text="成交量", row=2, col=1)
                fig.update_yaxes(title_text="MACD", row=3, col=1)
                fig.update_yaxes(title_text="RSI", row=4, col=1)

                st.plotly_chart(fig, use_container_width=True)
else:
    st.info("請在左側設定分析參數，然後點擊「執行 AI 分析」按鈕。")
    st.markdown("---")
    st.subheader("📖 應用程式說明")
    st.markdown("""
    本應用程式是一個基於專家系統規則的 AI 金融趨勢分析工具。它整合了多個維度的市場數據，為您提供一個全面的市場視圖。
    
    **功能亮點:**
    - **AI 融合信號**: 結合技術、基本面、動能等多個面向，產生具體的買賣建議與量化評分。
    - **多策略共識風控**: 透過運行多種算法，計算出穩健的止盈(TP)與止損(SL)參考價位。
    - **自動化回測**: 內建標準均線交叉策略，評估該策略在歷史數據上的表現。
    - **互動式圖表**: 提供包含多種關鍵指標的綜合 K 線圖，助您深入洞察市場動態。

    **使用步驟:**
    1. 在左側邊欄選擇您感興趣的 **資產類別** (美股、台股、加密貨幣)。
    2. 從 **熱門標的** 下拉選單中選擇，或 **手動輸入** 您想分析的股票/加密貨幣代碼。
    3. 選擇您想分析的 **時間週期**，從短線交易到長線投資。
    4. 點擊 **[📊 執行 AI 分析]** 按鈕，稍待片刻即可獲得完整的分析報告。

    **免責聲明:**
    本工具提供的所有資訊與分析結果僅供研究和參考，不構成任何投資建議。使用者應自行承擔所有投資風險。
    """)
